/**
* READ THIS DESCRIPTION!
*
* This is your processor module that will contain the bulk of your code submission. You are to implement
* a 5-stage pipelined processor in this module, accounting for hazards and implementing bypasses as
* necessary.
*
* Ultimately, your processor will be tested by a master skeleton, so the
* testbench can see which controls signal you active when. Therefore, there needs to be a way to
* "inject" imem, dmem, and regfile interfaces from some external controller module. The skeleton
* file, Wrapper.v, acts as a small wrapper around your processor for this purpose. Refer to Wrapper.v
* for more details.
*
* As a result, this module will NOT contain the RegFile nor the memory modules. Study the inputs
* very carefully - the RegFile-related I/Os are merely signals to be sent to the RegFile instantiated
* in your Wrapper module. This is the same for your memory elements.
*
*
*/
module processor(
// Control signals
clock, // I: The master clock
reset, // I: A reset signal

// Imem
address_imem, // O: The address of the data to get from imem
q_imem, // I: The data from imem

// Dmem
address_dmem, // O: The address of the data to get or put from/to dmem
data, // O: The data to write to dmem
wren, // O: Write enable for dmem
q_dmem, // I: The data from dmem

// Regfile
ctrl_writeEnable, // O: Write enable for RegFile
ctrl_writeReg, // O: Register to write to in RegFile
ctrl_readRegA, // O: Register to read from port A of RegFile
ctrl_readRegB, // O: Register to read from port B of RegFile
data_writeReg, // O: Data to write to for RegFile
data_readRegA, // I: Data from port A of RegFile
data_readRegB // I: Data from port B of RegFile

);

// Control signals
input clock, reset;

// Imem
output [31:0] address_imem;
input [31:0] q_imem;

// Dmem
output [31:0] address_dmem, data;
output wren;
input [31:0] q_dmem;

// Regfile
output ctrl_writeEnable;
output [4:0] ctrl_writeReg, ctrl_readRegA, ctrl_readRegB;
output [31:0] data_writeReg;
input [31:0] data_readRegA, data_readRegB;

//Latches reset signal
// wire r, s, q, q_not;
// nor nor_0(q, r, q_not);
// nor nor_1(q_not, q, s);

// assign r = reset;
// assign s = clock;

/*****************************Fetch*****************************/
wire [31:0] address_imem_new, address_imem_curr, address_imem_add;
//assign address_imem = address_imem_new;
//assign address_imem = q_not ? 32'b0 : address_imem_new;
//register address_reg(clock, 1'b1, reset, address_imem, address_imem_curr);

//assign ctrl_writeEnable = 1'b1;
wire placeholder, pc_neq, pc_lt;

wire pc_src;
//assign address_imem = pc_src ? exe_pc_out :  address_imem_new;

wire is_branch, is_jump;

assign is_branch = (exe_opcode == 5'b00010 & alu_notEqual) || (exe_opcode == 5'b00110 & alu_lessThan);
assign is_jump = (exe_opcode == 5'b00001) || (exe_opcode == 5'b00011);


wire stall_decode, stall_fetch, stall_execute, stall_memory;

assign reg_pc_w_en = 1;
assign stall_fetch = 0;
assign stall_decode = 0;
assign stall_execute = 0;
assign stall_memory = 0;

assign reg_f_d_w_en = !stall_fetch;
assign reg_d_x_w_en = !stall_decode;
assign reg_x_m_w_en = !stall_execute;
assign reg_m_w_w_en = !stall_memory;


cla_32_bit program_counter(address_imem, 32'b1, 1'b0, address_imem_add, placeholder, pc_neq, pc_lt);

wire [31:0] address_branch, is_normal_jump_plus_one;
assign address_branch = is_branch ? exe_pc_out : address_imem_add;

// cla_32_bit program_counter_jal(is_normal_jump, 32'b1, 1'b0, is_normal_jump_plus_one, placeholder, pc_neq, pc_lt);

// //Normal jump
// wire [31:0] is_normal_jump;
// assign is_normal_jump = is_jump ? exe_ji_t : address_branch;

// assign address_imem_new = (exe_opcode == 5'b00011) ? is_normal_jump_plus_one : is_normal_jump;

// //Normal jump
// wire [31:0] is_normal_jump;
assign address_imem_new = is_jump ? exe_ji_t : address_branch;

//assign address_imem_new = is_branch ? exe_pc_out : 32'bz;
//assign address_imem_new = is_jump ? exe_ji_t : address_imem_add;

wire reg_pc_w_en;
falling_register reg_pc(clock, reg_pc_w_en, reset, address_imem_new, address_imem);

wire [31:0] reg_f_d_out, reg_d_x_out, reg_x_m_out, reg_m_w_out;

wire reg_f_d_w_en;
falling_register reg_f_d(clock, reg_f_d_w_en, reset, q_imem, reg_f_d_out);


wire [31:0] fet_pc_out;
falling_register fet_pc(clock, 1'b1, reset, address_imem_add, fet_pc_out);


wire [31:0] reg_f_d_out_inter;
assign reg_f_d_out_inter = stall_fetch ? 32'b0 : reg_f_d_out;


/*****************************Decode*****************************/
wire reg_d_x_w_en;
falling_register reg_d_x(clock, reg_d_x_w_en, reset, reg_f_d_out_inter, reg_d_x_out);


wire [4:0] dec_opcode;
assign dec_opcode = reg_f_d_out[31:27];

wire [4:0] dec_rd = reg_f_d_out[26:22];
wire [4:0] dec_rs = reg_f_d_out[21:17];
wire [4:0] dec_rt = reg_f_d_out[16:12];


wire dec_is_alu = (dec_opcode == 5'b00000);
wire dec_is_addi = (dec_opcode == 5'b00101);

wire dec_is_sw = (dec_opcode == 5'b00111);
wire dec_is_lw = (dec_opcode == 5'b01000);

wire dec_is_jump = (dec_opcode == 5'b00001);
wire dec_is_jal = (dec_opcode == 5'b00011);
wire dec_is_jr = (dec_opcode == 5'b00100);

wire dec_is_bne = (dec_opcode == 5'b00010);
wire dec_is_blt = (dec_opcode == 5'b00110);

wire dec_is_bex = (dec_opcode == 5'b10110);
wire dec_is_setx = (dec_opcode == 5'b10101);


//ALU opcode constants
wire [4:0] add_OP, sub_OP, and_OP, or_OP, sll_OP, sra_OP;
assign add_OP = 5'b00000;
assign sub_OP = 5'b00001;
// assign and_OP = 5'b00010;
// assign or_OP  = 5'b00011;
// assign sll_OP = 5'b00001;

//Determines which ALU opcode to use
wire [4:0] dec_opcode_alu;
//Any alu instruction just uses the opcode directly
assign dec_opcode_alu = dec_is_alu ? reg_f_d_out[6:2] : 5'bz;
//Addi uses add
assign dec_opcode_alu = dec_is_addi ? add_OP : 5'bz ;
//Branch comparisons use sub
assign dec_opcode_alu = dec_is_bne || dec_is_blt ? sub_OP : 5'bz;


//Determines which instructions write to reg_file
wire dec_write_en = (dec_is_alu || dec_is_addi || dec_is_lw || dec_is_jal);

wire dec_is_branch = (dec_opcode == 5'b00010) || (dec_opcode == 5'b00110);


//For branch instructions $rd is read from instead of $rs to compare
assign ctrl_readRegA = dec_is_bne || dec_is_blt ? dec_rd : dec_rs; 

//Determines the destination register number
wire [4:0] dec_reg_dst;
assign dec_reg_dst = dec_is_jal ? 5'd31 : dec_rd;

//Determines if the alu uses the sign extended or other value. Only used for sw/lw & addi
wire dec_alu_src;
assign dec_alu_src = (dec_is_sw || dec_is_lw || dec_is_addi);

//Determines if a branch will be made
wire dec_branch;
assign dec_branch = dec_is_bne || dec_is_blt;



// //$rs
// assign ctrl_readRegA = reg_f_d_out[21:17];

//$rt or $rd if sw
//assign ctrl_readRegB = reg_f_d_out[16:12];

wire [31:0] dec_branch_B;
assign ctrl_readRegB = dec_is_sw ? dec_rd : dec_branch_B;
//branches
assign dec_branch_B = dec_is_branch ? dec_rs : dec_rt;

//Selects data to be stored into register file
//All arithmetic and addi instructions uses ALU_out, lw uses dmem, jal uses write_pc
wire [1:0] dec_mem_to_reg;
assign dec_mem_to_reg[0] = dec_is_jal;
assign dec_mem_to_reg[1] = dec_is_lw;

// assign ctrl_readRegB = dec_is_sw ? dec_rd : 5'bz;
// //branches
// assign ctrl_readRegB = dec_is_branch ? dec_rs : dec_rt;

// wire [31:0] dec_branch;
// assign ctrl_readRegB = dec_is_sw ? dec_branch : dec_rd;
// //branches
// assign dec_branch = dec_is_branch ? dec_rs : dec_rt;


wire alu_op_B_sel;


//Addi sign extension
wire [31:0] add_i_imm;
//q_imem[16:0];
wire [15:0] add_i_sign;
//assign wren = 1'b0;

//Sign extension for negative addi
assign add_i_sign = reg_f_d_out[16] ? 16'b1111111111111111 : 16'b0000000000000000;
assign add_i_imm = {add_i_sign, reg_f_d_out[16:0]};

assign d_x_A_in = data_readRegA;
assign d_x_B_in = data_readRegB;

wire [31:0] d_x_A_in, d_x_A_out, d_x_B_in, d_x_B_out, d_x_S_out;
falling_register reg_d_x_A(clock, 1'b1, reset, d_x_A_in, d_x_A_out);
falling_register reg_d_x_B(clock, 1'b1, reset, d_x_B_in, d_x_B_out);
falling_register reg_d_x_S(clock, 1'b1, reset, add_i_imm, d_x_S_out);


wire [31:0] exe_pc;
falling_register exe_reg_pc(clock, 1'b1, reset, fet_pc_out, exe_pc);



wire [31:0] reg_d_x_out_inter;
assign reg_d_x_out_inter = stall_decode ? 32'b0 : reg_d_x_out;
/*****************************Execute*****************************/
//Passed WE
wire exe_write_en;
dffe_ref_fall exe_we(exe_write_en, dec_write_en, clock, 1'b1, reset);

wire reg_x_m_w_en;
falling_register reg_x_m(clock, reg_x_m_w_en, reset, reg_d_x_out_inter, reg_x_m_out);

wire [31:0] exe_pc_out;
cla_32_bit exec_pc_add(exe_pc, d_x_S_out, 1'b0, exe_pc_out, placeholder, pc_neq, pc_lt);


//Opcode
wire [4:0] exe_opcode, exe_rd, exe_rs, exe_rt;
assign exe_opcode = reg_d_x_out[31:27];
assign exe_rd = reg_d_x_out[26:22]; 
assign exe_rs = reg_d_x_out[21:17];
assign exe_rt = reg_d_x_out[16:12];
wire exe_is_lw = (exe_opcode == 5'b01000);

//Pad bits for JI target
wire [32:0] exe_ji_t = {5'b0, reg_d_x_out[26:0]};

// //Addi sign extension
// wire [31:0] add_i_imm;
// //q_imem[16:0];
// wire [15:0] add_i_sign;
// //assign wren = 1'b0;

// //Sign extension for negative addi
// assign add_i_sign = reg_d_x_out[16] ? 16'b1111111111111111 : 16'b0000000000000000;
// assign add_i_imm = {add_i_sign, reg_d_x_out[16:0]};

//$rs
//assign ctrl_readRegA = q_imem[21:17];
//$rt
//assign ctrl_readRegB = q_imem[16:12];

//Shift amount
wire [4:0] shamt;
assign shamt = reg_d_x_out[11:7];

//ALU OP
wire [4:0] alu_op;
assign alu_op = reg_d_x_out[6:2];
//zeroes

//Selects either addi or normal alu operation
wire is00000opcode;
assign is00000opcode = exe_opcode == 0;


// //MX Bypass
//wire [31:0] alu_op_A;


// assign alu_op_A = (exe_rs == mem_rd) ? ALU_res : d_x_A_out;

//BNE = I

wire [31:0] ALU_out;
wire alu_lessThan, alu_notEqual, alu_overFlow, nan;

//module mux_4 (out, select, in0, in1, in2, in3);
wire [31:0] alu_op_A, alu_op_B;
wire [1:0] sel_A, sel_B;

mux_4 mux_alu_a(alu_op_A, sel_A, d_x_A_out, data_writeReg, ALU_res, ALU_res);
mux_4 mux_alu_b(alu_op_B, sel_B, d_x_B_out, data_writeReg, ALU_res, ALU_res);
//assign alu_lessThan = d_x_A_out < d_x_B_out;


alu alu(alu_op_A, alu_op_B_res, alu_act_op, shamt, ALU_out, alu_notEqual, alu_lessThan, alu_overFlow);
//assign address_imem = 32'b0;

//5'b00101
//module alu(data_operandA, data_operandB, ctrl_ALUopcode, ctrl_shiftamt, data_result, isNotEqual, isLessThan, overflow);
wire [31:0] ALU_res, reg_e_2_out;
wire [31:0] alu_op_B_res;

//assign alu_op_B_res = (is00000opcode || alu_is_branch) ? alu_op_B :  d_x_S_out;
assign alu_op_B_res = (is00000opcode || alu_is_branch) ? alu_op_B :  d_x_S_out;


wire [4:0] alu_act_op, alu_is_addi;


assign alu_is_addi = (exe_opcode == 5'b00101) ? add_OP :  alu_op;

wire alu_is_branch = (exe_opcode == 5'b00010) || (exe_opcode == 5'b00110);

assign alu_act_op = alu_is_branch ? sub_OP : alu_is_addi;

falling_register reg_alu(clock, 1'b1, reset, ALU_out, ALU_res);
falling_register reg_e_2(clock, 1'b1, reset, d_x_B_out, reg_e_2_out);
//register reg_b(clock, 1'b1, reset, reg_x_m_out, reg_m_w_out);
//alu alu(data_readRegA, add_i_imm, add_OP, 5'b0, temp_out, temp1, temp2, temp3);



wire [31:0] mem_pc;
falling_register mem_reg_pc(clock, 1'b1, reset, exe_pc, mem_pc);

wire [31:0] write_pc;
falling_register write_reg_pc(clock, 1'b1, reset, mem_pc, write_pc);


/*****************************Memory*****************************/
wire reg_m_w_w_en;
falling_register reg_m_w(clock, reg_m_w_w_en, reset, reg_x_m_out, reg_m_w_out);

wire mem_alu_exp;
dffe_ref_fall mem_alu_ovf(mem_alu_exp, alu_overFlow, clock, 1'b1, reset);

wire mem_write_en;
dffe_ref_fall mem_we(mem_write_en, exe_write_en, clock, 1'b1, reset);

wire [4:0] mem_opcode, mem_rd, mem_rs, mem_rt, mem_rd_in;
assign mem_opcode = reg_x_m_out[31:27];
assign mem_rd_in = reg_x_m_out[26:22]; 
assign mem_rs = reg_x_m_out[21:17];
assign mem_rt = reg_x_m_out[16:12];

wire mem_is_branch = (mem_opcode == 5'b00010) || (mem_opcode == 5'b00110);
wire mem_is_jump = (mem_opcode == 5'b00001);
wire mem_is_jal = (mem_opcode == 5'b00011);
wire mem_is_lw = (mem_opcode == 5'b01000);
wire mem_is_sw = (mem_opcode == 5'b00111);

//Destination Register
wire [4:0] mem_rd_jal;
assign mem_rd_jal = mem_is_jal ? 5'd31 : mem_rd_in;
assign mem_rd = mem_alu_exp ? 5'd30 : mem_rd_jal;

wire [31:0] mem_r_status_out;
mux_8 mem_rstatus(mem_r_status_out, write_alu_op[2:0], 32'd1, 32'd2, 32'd3, 32'd0, 32'd0, 32'd0, 32'd1, 32'd5);

//Memory data

// wire [31:0] mem_lw_data, mem_data_write_jal;
// assign mem_lw_data = mem_is_lw ? q_dmem : ALU_res;
// assign mem_data_write_jal = mem_is_jal ? write_pc : mem_lw_data;
// assign mem_data_writeReg = mem_alu_exp ? r_status_out : mem_data_write_jal;

//Only writes to the data memory if current operation is sw
//assign wren = mem_opcode == 00111 ? 1'b1 : 1'b0;
//data =
//reg_x_m_out
//$rd

assign address_dmem = ALU_res;
assign data = reg_e_2_out;
//Writes RAM if lw

//Only writes memory for sw
assign wren = (mem_opcode == 5'b00111);


wire [31:0] reg_m_alu_out, reg_m_read_out;
falling_register reg_m_alu(clock, 1'b1, reset, ALU_res, reg_m_alu_out);
falling_register reg_m_read(clock, 1'b1, reset, q_dmem, reg_m_read_out);

/*****************************Write*****************************/
wire wr_write_en;
dffe_ref_fall write_we(wr_write_en, mem_write_en, clock, 1'b1, reset);

wire write_alu_exp;
dffe_ref_fall write_alu_ovf(write_alu_exp, mem_alu_exp, clock, 1'b1, reset);

wire [4:0] write_opcode, write_rd, write_rs, write_rt, write_alu_op;
assign write_opcode = reg_m_w_out[31:27];
assign write_alu_op = reg_m_w_out[6:2];
assign write_rd = reg_m_w_out[26:22]; 
assign write_rs = reg_m_w_out[21:17];
assign write_rt = reg_m_w_out[16:12];

wire write_is_branch = (write_opcode == 5'b00010) || (write_opcode == 5'b00110);
wire write_is_jump = (write_opcode == 5'b00001);
wire write_is_jal = (write_opcode == 5'b00011);
wire write_is_lw = (write_opcode == 5'b01000);
wire write_is_sw = (write_opcode == 5'b00111);

//Always writes memory except for listed exceptions
//assign ctrl_writeEnable = !(write_is_sw || write_is_branch || write_is_jump);
assign ctrl_writeEnable = wr_write_en; 

//Register address to write to, is always $rd except for jal instructions or overflow
wire [4:0] ctrl_write_jal;
assign ctrl_write_jal = write_is_jal ? 5'd31 : write_rd;
assign ctrl_writeReg = write_alu_exp ? 5'd30 : ctrl_write_jal;

//Register data to write
//wire [31:0] lw_data;

//assign data_writeReg = write_is_lw? q_dmem : reg_m_alu_out;

//assign data_writeReg = write_is_jal ? write_pc : reg_m_alu_out;

//All arithmetic and addi instructions uses ALU_out, lw uses dmem write_pc
//module mux_8 (out, select, in0, in1, in2, in3, in4, in5, in6, in7);

wire [31:0] r_status_out;
mux_8 rstatus(r_status_out, write_alu_op[2:0], 32'd1, 32'd2, 32'd3, 32'd0, 32'd0, 32'd0, 32'd1, 32'd5);


wire [31:0] lw_data, data_write_jal;
assign lw_data = write_is_lw ? reg_m_read_out : reg_m_alu_out;
assign data_write_jal = write_is_jal ? write_pc : lw_data;
assign data_writeReg = write_alu_exp ? r_status_out : data_write_jal;


wire mem_writeEnable;
assign mem_writeEnable = !(mem_is_sw || mem_is_branch || mem_is_jump);

// assign sel_A[1] = mem_write_en & (mem_rd == exe_rs) & (mem_rd != 0);

// assign sel_B[1] = mem_write_en & (mem_rd == exe_rt) & (mem_rd != 0);

// assign sel_A[0] = ctrl_writeEnable & (write_rd != 0) & !(mem_write_en & (mem_rd != 0) & (mem_rd != exe_rs)) & (write_rd == exe_rs);

// assign sel_B[0] = ctrl_writeEnable & (write_rd != 0) & !(mem_write_en & (mem_rd != 0) & (mem_rd != exe_rt)) & (write_rd == exe_rt);

assign sel_A[1] = !(mem_opcode == 5'b00111) & (mem_rd == exe_rs) & (mem_rd != 0);
assign sel_B[1] = !(mem_opcode == 5'b00111) & (mem_rd == exe_rt) & (mem_rd != 0);

assign sel_A[0] = ctrl_writeEnable & (write_rd == exe_rs) & (write_rd != 0);
assign sel_B[0] = ctrl_writeEnable & (write_rd == exe_rt) & (write_rd != 0);

wire stall;
assign stall = is_jump;
//assign stall = exe_is_lw & ((exe_rt == dec_rs) || (exe_rt == dec_rt));
assign stall = exe_is_lw & ((dec_rs == exe_rd) || ((dec_rt == exe_rd) & (!dec_is_sw)));
// assign sel_A[0] = 0;
// assign sel_B[0] = 0;
// assign sel_A[1] = 0;
// assign sel_B[1] = 0;

// mem_rd == exe_rs
// mem_rd == exe_rt
// write_rd = exe_rs
// write_rd == exe_rt


/* END CODE */
endmodule


/**
* READ THIS DESCRIPTION!
*
* This is your processor module that will contain the bulk of your code submission. You are to implement
* a 5-stage pipelined processor in this module, accounting for hazards and implementing bypasses as
* necessary.
*
* Ultimately, your processor will be tested by a master skeleton, so the
* testbench can see which controls signal you active when. Therefore, there needs to be a way to
* "inject" imem, dmem, and regfile interfaces from some external controller module. The skeleton
* file, Wrapper.v, acts as a small wrapper around your processor for this purpose. Refer to Wrapper.v
* for more details.
*
* As a result, this module will NOT contain the RegFile nor the memory modules. Study the inputs
* very carefully - the RegFile-related I/Os are merely signals to be sent to the RegFile instantiated
* in your Wrapper module. This is the same for your memory elements.
*
*
*/
module processor(
// Control signals
clock, // I: The master clock
reset, // I: A reset signal

// Imem
address_imem, // O: The address of the data to get from imem
q_imem, // I: The data from imem

// Dmem
address_dmem, // O: The address of the data to get or put from/to dmem
data, // O: The data to write to dmem
wren, // O: Write enable for dmem
q_dmem, // I: The data from dmem

// Regfile
ctrl_writeEnable, // O: Write enable for RegFile
ctrl_writeReg, // O: Register to write to in RegFile
ctrl_readRegA, // O: Register to read from port A of RegFile
ctrl_readRegB, // O: Register to read from port B of RegFile
data_writeReg, // O: Data to write to for RegFile
data_readRegA, // I: Data from port A of RegFile
data_readRegB // I: Data from port B of RegFile

);

// Control signals
input clock, reset;

// Imem
output [31:0] address_imem;
input [31:0] q_imem;

// Dmem
output [31:0] address_dmem, data;
output wren;
input [31:0] q_dmem;

// Regfile
output ctrl_writeEnable;
output [4:0] ctrl_writeReg, ctrl_readRegA, ctrl_readRegB;
output [31:0] data_writeReg;
input [31:0] data_readRegA, data_readRegB;

//Latches reset signal
// wire r, s, q, q_not;
// nor nor_0(q, r, q_not);
// nor nor_1(q_not, q, s);

// assign r = reset;
// assign s = clock;

/*****************************Fetch*****************************/
wire ctrl_all_latch;
wire [31:0] address_imem_new, address_imem_curr;
//assign address_imem = address_imem_new;
//assign address_imem = q_not ? 32'b0 : address_imem_new;
//register address_reg(clock, 1'b1, reset, address_imem, address_imem_curr);

//assign ctrl_writeEnable = 1'b1;
wire placeholder, pc_neq, pc_lt;
cla_32_bit program_counter(address_imem_curr, 32'b1, 1'b0, address_imem, placeholder, pc_neq, pc_lt);

wire reg_pc_we;
falling_register reg_pc(clock, reg_pc_we, reset, address_imem, address_imem_curr);


wire [31:0] reg_f_d_out, reg_d_x_out, reg_x_m_out, reg_m_w_out;
falling_register reg_f_d(clock, ctrl_all_latch, reset, q_imem, reg_f_d_out);


/*****************************Decode*****************************/
wire [31:0] reg_d_x_im;
falling_register reg_d_x(clock, ctrl_all_latch, reset, reg_f_d_out, reg_d_x_im);



wire [4:0] dec_opcode;
assign dec_opcode = reg_f_d_out[31:27];

//$rs
assign ctrl_readRegA = reg_f_d_out[21:17];
//$rt or $rd if sw
//assign ctrl_readRegB = reg_f_d_out[16:12];
assign ctrl_readRegB = (dec_opcode == 5'b00111) ? reg_f_d_out[26:22] : reg_f_d_out[16:12];

wire hazard = 0;
wire [31:0] nop = 32'd0;

assign reg_pc_we = !(haz_test);
assign ctrl_all_latch = !(haz_test);

assign reg_d_x_out = hazard ? nop : reg_d_x_im;


//Addi sign extension
wire [31:0] add_i_imm;
//q_imem[16:0];
wire [15:0] add_i_sign;
//assign wren = 1'b0;

//Sign extension for negative addi
assign add_i_sign = reg_f_d_out[16] ? 16'b1111111111111111 : 16'b0000000000000000;
assign add_i_imm = {add_i_sign, reg_f_d_out[16:0]};



assign d_x_A_in = data_readRegA;
assign d_x_B_in = data_readRegB;

wire [31:0] d_x_A_in, d_x_A_out, d_x_B_in, d_x_B_out, d_x_S_out;
falling_register reg_d_x_A(clock, ctrl_all_latch, reset, d_x_A_in, d_x_A_out);
falling_register reg_d_x_B(clock, ctrl_all_latch, reset, d_x_B_in, d_x_B_out);
falling_register reg_d_x_S(clock, ctrl_all_latch, reset, add_i_imm, d_x_S_out);

/*****************************Execute*****************************/
falling_register reg_x_m(clock, ctrl_all_latch, reset, reg_d_x_out, reg_x_m_out);

//Opcode
wire [4:0] exe_opcode, exe_rd, exe_rs, exe_rt;
assign exe_opcode = reg_d_x_out[31:27];
assign exe_rd = reg_d_x_out[26:22]; 
assign exe_rs = reg_d_x_out[21:17];
assign exe_rt = reg_d_x_out[16:12];

// //Addi sign extension
// wire [31:0] add_i_imm;
// //q_imem[16:0];
// wire [15:0] add_i_sign;
// //assign wren = 1'b0;

// //Sign extension for negative addi
// assign add_i_sign = reg_d_x_out[16] ? 16'b1111111111111111 : 16'b0000000000000000;
// assign add_i_imm = {add_i_sign, reg_d_x_out[16:0]};


//$rs
//assign ctrl_readRegA = q_imem[21:17];
//$rt
//assign ctrl_readRegB = q_imem[16:12];


//Shift amount
wire [4:0] shamt;
assign shamt = reg_d_x_out[11:7];

//ALU OP
wire [4:0] alu_op;
assign alu_op = reg_d_x_out[6:2];
//zeroes

wire [4:0] add_OP, sub_OP, and_OP, or_OP, sll_OP, sra_OP;
assign add_OP = 5'd0;
assign sub_OP = 5'd1;

//Selects either addi or normal alu operation
wire is00000opcode;
assign is00000opcode = exe_opcode == 0;

// //MX Bypass
//wire [31:0] alu_op_A;
// assign alu_op_A = (exe_rs == mem_rd) ? ALU_res : d_x_A_out;

wire [31:0] ALU_out;
wire lessThan, notEqual, overFlow;

//module mux_4 (out, select, in0, in1, in2, in3);
wire [31:0] alu_op_A, alu_op_B;
wire [1:0] sel_A, sel_B;

mux_4 mux_alu_a(alu_op_A, sel_A, d_x_A_out, data_writeReg, ALU_res, ALU_res);
mux_4 mux_alu_b(alu_op_B, sel_B, d_x_B_out, data_writeReg, ALU_res, ALU_res);


//module multdiv(data_operandA, data_operandB, ctrl_MULT, ctrl_DIV, clock, data_result, data_exception, data_resultRDY);
wire div_op, mult_op, multdiv_exp, multdiv_ready, mult_ready, div_ready;
assign div_op = alu_op == 5'b00111;
assign mult_op = alu_op == 5'b00110;

wire [31:0] multidiv_result;
multdiv multdiv(alu_op_A, alu_op_B_res, mult_op, div_op_one, clock, multidiv_result, multdiv_exp, multdiv_ready);

wire haz_test;
//(mult_op & !multdiv_ready)
assign haz_test =  (div_op & !div_ready) || (mult_op & !mult_ready);

wire [5:0] cout;
counter_64 count(clock, !div_op, cout);

assign div_op_one = (cout == 0);

wire c3, div_op_one;
//DFF circuit for keeping the ready signal high for one clock cycle
// dffe_ref dff_2(c3, div_op, clock, 1'b1, 1'b0);
// dffe_ref dff_3(div_op_one, c3, clock, 1'b1, 1'b0);

alu alu(alu_op_A, alu_op_B_res, alu_act_op, shamt, ALU_out, notEqual, lessThan, overFlow);
//assign address_imem = 32'b0;

//5'b00101
//module alu(data_operandA, data_operandB, ctrl_ALUopcode, ctrl_shiftamt, data_result, isNotEqual, isLessThan, overflow);
wire [31:0] ALU_res, reg_e_2_out;

wire [31:0] alu_op_B_res;
assign alu_op_B_res = is00000opcode ? alu_op_B :  d_x_S_out;

wire [4:0] alu_act_op;
assign alu_act_op = is00000opcode ? alu_op : add_OP;

falling_register reg_alu(clock, ctrl_all_latch, reset, ALU_out, ALU_res);
falling_register reg_e_2(clock, ctrl_all_latch, reset, d_x_B_out, reg_e_2_out);
//register reg_b(clock, 1'b1, reset, reg_x_m_out, reg_m_w_out);
//alu alu(data_readRegA, add_i_imm, add_OP, 5'b0, temp_out, temp1, temp2, temp3);


/*****************************Memory*****************************/
falling_register reg_m_w(clock, ctrl_all_latch, reset, reg_x_m_out, reg_m_w_out);

wire [4:0] mem_opcode, mem_rd, mem_rs, mem_rt;
assign mem_opcode = reg_x_m_out[31:27];
assign mem_rd = reg_x_m_out[26:22]; 
assign mem_rs = reg_x_m_out[21:17];
assign mem_rt = reg_x_m_out[16:12];

//Only writes to the data memory if current operation is sw
//assign wren = mem_opcode == 00111 ? 1'b1 : 1'b0;
//data =

//reg_x_m_out
//$rd

assign address_dmem = ALU_res;
assign data = reg_e_2_out;
//Writes RAM if lw

//Only writes memory for sw
assign wren = (mem_opcode == 5'b00111);


wire [31:0] reg_m_alu_out, reg_m_read_out;
falling_register reg_m_alu(clock, ctrl_all_latch, reset, ALU_res, reg_m_alu_out);
falling_register reg_m_read(clock, ctrl_all_latch, reset, q_dmem, reg_m_read_out);

/*****************************Write*****************************/
wire [4:0] write_opcode, write_rd, write_rs, write_rt;
assign write_opcode = reg_m_w_out[31:27];
assign write_rd = reg_m_w_out[26:22]; 
assign write_rs = reg_m_w_out[21:17];
assign write_rt = reg_m_w_out[16:12];

//Always writes memory except for sw
assign ctrl_writeEnable = !(write_opcode == 5'b00111);

//Register address to write to
assign ctrl_writeReg = reg_m_w_out[26:22];

//Register data to write
assign data_writeReg = (write_opcode == 5'b01000) ? q_dmem : reg_m_alu_out;


assign sel_A[1] = !(mem_opcode == 5'b00111) & (mem_rd == exe_rs) & (mem_rd != 0);

assign sel_B[1] = !(mem_opcode == 5'b00111) & (mem_rd == exe_rt) & (mem_rd != 0);

assign sel_A[0] = ctrl_writeEnable & (write_rd == exe_rs) & (write_rd != 0);
//assign sel_A[0] = 0;

assign sel_B[0] = ctrl_writeEnable &(write_rd == exe_rt) & (write_rd != 0);

// mem_rd == exe_rs
// mem_rd == exe_rt
// write_rd = exe_rs
// write_rd == exe_rt


/* END CODE */
endmodule

